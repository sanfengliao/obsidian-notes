/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CopyDocumentAsHTMLPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
function allWithProgress(promises, callback) {
  let count = 0;
  callback(0);
  for (const promise of promises) {
    promise.then(() => {
      count++;
      callback(count * 100 / promises.length);
    });
  }
  return Promise.all(promises);
}
async function delay(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}
var MERMAID_STYLESHEET = `
:root {
  --default-font: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
  --font-monospace: 'Source Code Pro', monospace;
  --background-primary: #ffffff;
  --background-modifier-border: #ddd;
  --text-accent: #705dcf;
  --text-accent-hover: #7a6ae6;
  --text-normal: #2e3338;
  --background-secondary: #f2f3f5;
  --background-secondary-alt: #fcfcfc;
  --text-muted: #888888;
  --font-mermaid: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
  --text-error: #E4374B;
  --background-primary-alt: '#fafafa';
  --background-accent: '';
  --interactive-accent: hsl( 254,  80%, calc( 68% + 2.5%));
  --background-modifier-error: #E4374B;
  --background-primary-alt: #fafafa;
  --background-modifier-border: #e0e0e0;
}
`;
var copyIsRunning = false;
var ppIsProcessing = false;
var ppLastBlockDate = Date.now();
var documentRendererDefaults = {
  convertSvgToBitmap: true,
  removeFrontMatter: true,
  formatCodeWithTables: false,
  formatCalloutsWithTables: false,
  embedExternalLinks: false,
  removeDataviewMetadataLines: false,
  footnoteHandling: 2 /* REMOVE_LINK */,
  internalLinkHandling: 0 /* CONVERT_TO_TEXT */,
  disableImageEmbedding: false
};
var DocumentRenderer = class {
  constructor(app, options = documentRendererDefaults) {
    this.app = app;
    this.options = options;
    // time required after last block was rendered before we decide that rendering a view is completed
    this.optionRenderSettlingDelay = 100;
    // only those which are different from image/${extension}
    this.mimeMap = /* @__PURE__ */ new Map([
      ["svg", "image/svg+xml"],
      ["jpg", "image/jpeg"]
    ]);
    this.externalSchemes = ["http", "https"];
    this.vaultPath = this.app.vault.getRoot().vault.adapter.getBasePath().replace(/\\/g, "/");
    this.vaultLocalUriPrefix = `app://local/${this.vaultPath}`;
    this.vaultOpenUri = `obsidian://open?vault=${encodeURIComponent(
      this.app.vault.getName()
    )}`;
    this.vaultSearchUri = `obsidian://search?vault=${encodeURIComponent(
      this.app.vault.getName()
    )}`;
    this.view = new import_obsidian.Component();
  }
  /**
   * Render document into detached HTMLElement
   */
  async renderDocument(markdown, path) {
    try {
      const topNode = await this.renderMarkdown(markdown, path);
      return await this.transformHTML(topNode);
    } finally {
    }
  }
  /**
   * Render current view into HTMLElement, expanding embedded links
   */
  async renderMarkdown(markdown, path) {
    const processedMarkdown = this.preprocessMarkdown(markdown);
    const wrapper = document.createElement("div");
    wrapper.style.display = "hidden";
    document.body.appendChild(wrapper);
    await import_obsidian.MarkdownRenderer.render(
      this.app,
      processedMarkdown,
      wrapper,
      path,
      this.view
    );
    await this.untilRendered();
    await this.loadComponents(this.view);
    const result = wrapper.cloneNode(true);
    document.body.removeChild(wrapper);
    this.view.unload();
    return result;
  }
  /**
   * Some plugins may expose components that rely on onload() to be called which isn't the case due to the
   * way we render the markdown. We need to call onload() on all components to ensure they are properly loaded.
   * Since this is a bit of a hack (we need to access Obsidian internals), we limit this to components of which
   * we know that they don't get rendered correctly otherwise.
   * We attempt to make sure that if the Obsidian internals change, this will fail gracefully.
   */
  async loadComponents(view) {
    const internalView = view;
    const loadChildren = async (component, visited = /* @__PURE__ */ new Set()) => {
      var _a, _b;
      if (visited.has(component)) {
        return;
      }
      visited.add(component);
      const internalComponent = component;
      if ((_a = internalComponent._children) == null ? void 0 : _a.length) {
        for (const child of internalComponent._children) {
          await loadChildren(child, visited);
        }
      }
      try {
        if (((_b = component == null ? void 0 : component.constructor) == null ? void 0 : _b.name) === "SheetElement") {
          await component.onload();
        }
      } catch (error) {
        console.error(`Error calling onload()`, error);
      }
    };
    await loadChildren(internalView);
  }
  preprocessMarkdown(markdown) {
    let processed = markdown;
    if (this.options.removeDataviewMetadataLines) {
      processed = processed.replace(/^[^ \t:#`<>][^:#`<>]+::.*$/gm, "");
    }
    processed = this.ensureParagraphSpacing(processed);
    return processed;
  }
  // ========== 段落分隔辅助函数 ==========
  /** 判断是否是无序列表行 */
  isUnorderedListLine(trimmed) {
    return trimmed.startsWith("-") || trimmed.startsWith("*");
  }
  /** 判断是否是有序列表行（数字开头） */
  isOrderedListLine(trimmed) {
    return /^\d+\.\s/.test(trimmed);
  }
  /** 判断行是否有缩进（以空格或 tab 开头） */
  hasIndent(line) {
    return /^[ \t]/.test(line);
  }
  /** 判断是否是列表标记行（需要结合上下文） */
  isListMarkerLine(trimmed, inOrderedList) {
    if (this.isUnorderedListLine(trimmed)) {
      return true;
    }
    if (this.isOrderedListLine(trimmed)) {
      return trimmed.startsWith("1.") || inOrderedList;
    }
    return false;
  }
  /** 判断是否是独立段落（非空、非特殊标记、不在列表上下文中的缩进行） */
  isIndependentParagraph(line, trimmed, inOrderedList, inListContext) {
    if (trimmed.length === 0) return false;
    if (trimmed.startsWith("#")) return false;
    if (trimmed.startsWith(">")) return false;
    if (trimmed.startsWith("|")) return false;
    if (trimmed.startsWith("```")) return false;
    if (this.isListMarkerLine(trimmed, inOrderedList)) return false;
    if (this.hasIndent(line) && inListContext) return false;
    return true;
  }
  /**
   * 确保段落之间有空行分隔
   * 这样 Markdown 渲染时每个段落都会生成独立的 <p> 标签
   */
  ensureParagraphSpacing(markdown) {
    const lines = markdown.split("\n");
    const result = [];
    let inCodeBlock = false;
    let inFrontMatter = false;
    let frontMatterCount = 0;
    let inOrderedList = false;
    let inListContext = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      if (i === 0 && trimmedLine === "---") {
        inFrontMatter = true;
        frontMatterCount = 1;
      } else if (inFrontMatter && trimmedLine === "---") {
        frontMatterCount++;
        if (frontMatterCount >= 2) {
          inFrontMatter = false;
        }
      }
      if (trimmedLine.startsWith("```")) {
        inCodeBlock = !inCodeBlock;
      }
      if (!inCodeBlock && !inFrontMatter) {
        if (this.isUnorderedListLine(trimmedLine)) {
          inOrderedList = false;
          inListContext = true;
        } else if (trimmedLine.startsWith("1.")) {
          inOrderedList = true;
          inListContext = true;
        } else if (this.isOrderedListLine(trimmedLine) && inOrderedList) {
          inListContext = true;
        } else if (trimmedLine === "" || !this.hasIndent(line) && !this.isOrderedListLine(trimmedLine)) {
          inOrderedList = false;
          inListContext = false;
        } else if (this.hasIndent(line) && inListContext) {
        } else {
          inListContext = false;
        }
      }
      result.push(line);
      if (!inCodeBlock && !inFrontMatter && i < lines.length - 1) {
        const nextLine = lines[i + 1];
        const nextTrimmed = nextLine.trim();
        if (this.isIndependentParagraph(
          nextLine,
          nextTrimmed,
          inOrderedList,
          inListContext
        )) {
          result.push("");
        }
      }
    }
    return result.join("\n");
  }
  /**
   * Wait until the view has finished rendering
   *
   * Beware, this is a dirty hack...
   *
   * We have no reliable way to know if the document finished rendering. For instance dataviews or task blocks
   * may not have been post processed.
   * MarkdownPostProcessors are called on all the "blocks" in the HTML view. So we register one post-processor
   * with high-priority (low-number to mark the block as being processed), and another one with low-priority that
   * runs after all other post-processors.
   * Now if we see that no blocks are being post-processed, it can mean 2 things :
   *  - either we are between blocks
   *  - or we finished rendering the view
   * On the premise that the time that elapses between the post-processing of consecutive blocks is always very
   * short (just iteration, no work is done), we conclude that the render is finished if no block has been
   * rendered for enough time.
   */
  async untilRendered() {
    while (ppIsProcessing || Date.now() - ppLastBlockDate < this.optionRenderSettlingDelay) {
      if (ppLastBlockDate === 0) {
        break;
      }
      await delay(20);
    }
  }
  /**
   * Transform rendered markdown to clean it up and embed images
   */
  async transformHTML(element) {
    const node = element.cloneNode(true);
    node.removeAttribute("style");
    if (this.options.removeFrontMatter) {
      this.removeFrontMatter(node);
    }
    this.replaceLinksOfClass(node, "internal-link");
    this.replaceLinksOfClass(node, "tag");
    this.makeCheckboxesReadOnly(node);
    this.removeCollapseIndicators(node);
    this.removeButtons(node);
    this.removeStrangeNewWorldsLinks(node);
    this.normalizeCodeBlocks(node);
    if (this.options.formatCodeWithTables) {
      this.transformCodeToTables(node);
    }
    if (this.options.formatCalloutsWithTables) {
      this.transformCalloutsToTables(node);
    }
    if (this.options.footnoteHandling == 0 /* REMOVE_ALL */) {
      this.removeAllFootnotes(node);
    }
    if (this.options.footnoteHandling == 2 /* REMOVE_LINK */) {
      this.removeFootnoteLinks(node);
    } else if (this.options.footnoteHandling == 3 /* TITLE_ATTRIBUTE */) {
    }
    if (!this.options.disableImageEmbedding) {
      await this.embedImages(node);
      await this.renderSvg(node);
    }
    return node;
  }
  /** Remove front-matter */
  removeFrontMatter(node) {
    node.querySelectorAll(".frontmatter, .frontmatter-container").forEach(
      (node2) => node2.remove()
    );
  }
  replaceLinksOfClass(node, className) {
    if (this.options.internalLinkHandling === 3 /* LEAVE_AS_IS */) {
      return;
    }
    node.querySelectorAll(`a.${className}`).forEach((node2) => {
      switch (this.options.internalLinkHandling) {
        case 1 /* CONVERT_TO_OBSIDIAN_URI */:
          {
            const linkNode = node2.parentNode.createEl("a");
            linkNode.innerText = node2.getText();
            if (className === "tag") {
              linkNode.href = this.vaultSearchUri + "&query=tag:" + encodeURIComponent(node2.getAttribute("href"));
            } else {
              if (node2.getAttribute("href").startsWith("#")) {
                linkNode.href = node2.getAttribute("href");
              } else {
                linkNode.href = this.vaultOpenUri + "&file=" + encodeURIComponent(
                  node2.getAttribute("href")
                );
              }
            }
            linkNode.className = className;
            node2.parentNode.replaceChild(linkNode, node2);
          }
          break;
        case 2 /* LINK_TO_HTML */:
          {
            const linkNode = node2.parentNode.createEl("a");
            linkNode.innerText = node2.getAttribute("href");
            linkNode.className = className;
            if (node2.getAttribute("href").startsWith("#")) {
              linkNode.href = node2.getAttribute("href");
            } else {
              linkNode.href = node2.getAttribute("href").replace(
                /^(.*?)(?:\.md)?(#.*?)?$/,
                "$1.html$2"
              );
            }
            node2.parentNode.replaceChild(linkNode, node2);
          }
          break;
        case 0 /* CONVERT_TO_TEXT */:
        default:
          {
            const textNode = node2.parentNode.createEl("span");
            textNode.innerText = node2.getText();
            textNode.className = className;
            node2.parentNode.replaceChild(textNode, node2);
          }
          break;
      }
    });
  }
  makeCheckboxesReadOnly(node) {
    node.querySelectorAll('input[type="checkbox"]').forEach(
      (node2) => node2.setAttribute("disabled", "disabled")
    );
  }
  /** Remove the collapse indicators from HTML, not needed (and not working) in copy */
  removeCollapseIndicators(node) {
    node.querySelectorAll(".collapse-indicator").forEach(
      (node2) => node2.remove()
    );
  }
  /** Remove button elements (which appear after code blocks) */
  removeButtons(node) {
    node.querySelectorAll("button").forEach((node2) => node2.remove());
  }
  /** Remove counters added by Strange New Worlds plugin (https://github.com/TfTHacker/obsidian42-strange-new-worlds) */
  removeStrangeNewWorldsLinks(node) {
    node.querySelectorAll(".snw-reference").forEach(
      (node2) => node2.remove()
    );
  }
  /** 将代码块统一为 <pre><code>纯文本</code></pre> 格式，去掉高亮标识 */
  normalizeCodeBlocks(node) {
    node.querySelectorAll("pre").forEach((preEl) => {
      const codeEl = preEl.querySelector("code");
      if (codeEl) {
        const text = codeEl.textContent || "";
        codeEl.innerHTML = "";
        codeEl.textContent = text;
      }
    });
  }
  /** Transform code blocks to tables */
  transformCodeToTables(node) {
    node.querySelectorAll("pre").forEach((node2) => {
      const codeEl = node2.querySelector("code");
      if (codeEl) {
        const code = codeEl.innerHTML.replace(/\n*$/, "");
        const table = node2.parentElement.createEl("table");
        table.className = "source-table";
        table.innerHTML = `<tr><td><pre><code>${code}</code></pre></td></tr>`;
        node2.parentElement.replaceChild(table, node2);
      }
    });
  }
  /** Transform callouts to tables */
  transformCalloutsToTables(node) {
    node.querySelectorAll(".callout").forEach((node2) => {
      var _a;
      const callout = node2.parentElement.createEl("table");
      callout.addClass("callout-table", "callout");
      callout.setAttribute(
        "data-callout",
        (_a = node2.getAttribute("data-callout")) != null ? _a : "quote"
      );
      const headRow = callout.createEl("tr");
      const headColumn = headRow.createEl("td");
      headColumn.addClass("callout-title");
      const title = node2.querySelector(".callout-title-inner");
      if (title) {
        const span = headColumn.createEl("span");
        span.innerHTML = title.innerHTML;
      }
      const originalContent = node2.querySelector(".callout-content");
      if (originalContent) {
        const row = callout.createEl("tr");
        const column = row.createEl("td");
        column.innerHTML = originalContent.innerHTML;
      }
      node2.replaceWith(callout);
    });
  }
  /** Remove references to footnotes and the footnotes section */
  removeAllFootnotes(node) {
    node.querySelectorAll("section.footnotes").forEach(
      (section) => section.parentNode.removeChild(section)
    );
    node.querySelectorAll(".footnote-link").forEach((link) => {
      link.parentNode.parentNode.removeChild(link.parentNode);
    });
  }
  /** Keep footnotes and references, but remove links */
  removeFootnoteLinks(node) {
    node.querySelectorAll(".footnote-link").forEach((link) => {
      const text = link.getText();
      if (text === "\u21A9\uFE0E") {
        link.parentNode.removeChild(link);
      } else {
        const span = link.parentNode.createEl("span", {
          text: link.getText(),
          cls: "footnote-link"
        });
        link.parentNode.replaceChild(span, link);
      }
    });
  }
  /** Replace all images sources with a data-uri */
  async embedImages(node) {
    const promises = [];
    node.querySelectorAll("img").forEach((img) => {
      var _a;
      if (img.src) {
        if (img.src.startsWith("data:image/svg+xml") && this.options.convertSvgToBitmap) {
          promises.push(this.replaceImageSource(img));
          return;
        }
        if (!this.options.embedExternalLinks) {
          const [scheme] = img.src.split(":", 1);
          if (this.externalSchemes.includes(
            (_a = scheme == null ? void 0 : scheme.toLowerCase()) != null ? _a : ""
          )) {
            return;
          } else {
          }
        }
        if (!img.src.startsWith("data:")) {
          promises.push(this.replaceImageSource(img));
          return;
        }
      }
    });
    this.modal.progress.max = 100;
    await allWithProgress(
      promises,
      // @ts-ignore
      (percentCompleted) => this.modal.progress.value = percentCompleted
    );
    return node;
  }
  async renderSvg(node) {
    const xmlSerializer = new XMLSerializer();
    if (!this.options.convertSvgToBitmap) {
      return node;
    }
    const promises = [];
    const replaceSvg = async (svg) => {
      const style = svg.querySelector("style") || svg.appendChild(document.createElement("style"));
      style.innerHTML += MERMAID_STYLESHEET;
      const svgAsString = xmlSerializer.serializeToString(svg);
      const svgData = `data:image/svg+xml;base64,` + Buffer.from(svgAsString).toString("base64");
      const dataUri = await this.imageToDataUri(svgData);
      const img = svg.createEl("img");
      img.style.cssText = svg.style.cssText;
      img.src = dataUri;
      svg.parentElement.replaceChild(img, svg);
    };
    node.querySelectorAll("svg").forEach((svg) => {
      promises.push(replaceSvg(svg));
    });
    await Promise.allSettled(promises);
    return node;
  }
  /** replace image src attribute with data uri */
  async replaceImageSource(image) {
    const imageSourcePath = decodeURI(image.src);
    if (imageSourcePath.startsWith(this.vaultLocalUriPrefix)) {
      let path = imageSourcePath.substring(this.vaultLocalUriPrefix.length + 1).replace(/[?#].*/, "");
      path = decodeURI(path);
      const mimeType = this.guessMimeType(path);
      const data = await this.readFromVault(path, mimeType);
      if (this.isSvg(mimeType) && this.options.convertSvgToBitmap) {
        image.src = await this.imageToDataUri(data);
      } else {
        image.src = data;
      }
    } else {
      image.src = await this.imageToDataUri(image.src);
    }
  }
  /**
   * Draw image url to canvas and return as data uri containing image pixel data
   */
  async imageToDataUri(url) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const image = new Image();
    image.setAttribute("crossOrigin", "anonymous");
    const dataUriPromise = new Promise((resolve, reject) => {
      image.onload = () => {
        canvas.width = image.naturalWidth;
        canvas.height = image.naturalHeight;
        ctx.drawImage(image, 0, 0);
        try {
          const uri = canvas.toDataURL("image/png");
          resolve(uri);
        } catch (err) {
          console.log(`failed ${url}`, err);
          resolve(url);
        }
        canvas.remove();
      };
      image.onerror = (err) => {
        console.log("could not load data uri");
        resolve(url);
      };
    });
    image.src = url;
    return dataUriPromise;
  }
  /**
   * Get binary data as b64 from a file in the vault
   */
  async readFromVault(path, mimeType) {
    const tfile = this.app.vault.getAbstractFileByPath(path);
    const data = await this.app.vault.readBinary(tfile);
    return `data:${mimeType};base64,` + (0, import_obsidian.arrayBufferToBase64)(data);
  }
  /** Guess an image's mime-type based on its extension */
  guessMimeType(filePath) {
    const extension = this.getExtension(filePath) || "png";
    return this.mimeMap.get(extension) || `image/${extension}`;
  }
  /** Get lower-case extension for a path */
  getExtension(filePath) {
    const fileName = filePath.slice(filePath.lastIndexOf("/") + 1);
    return fileName.slice(fileName.lastIndexOf(".") + 1 || fileName.length).toLowerCase();
  }
  isSvg(mimeType) {
    return mimeType === "image/svg+xml";
  }
};
var _CopyDocumentAsHTMLSettingsTab = class _CopyDocumentAsHTMLSettingsTab extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Copy Plus Settings" });
    containerEl.createEl("h3", { text: "Compatibility" });
    new import_obsidian.Setting(containerEl).setName("Convert SVG files to bitmap").setDesc(
      "If checked, SVG files are converted to bitmap. This makes the copied documents heavier but improves compatibility (eg. with gmail)."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.convertSvgToBitmap).onChange(async (value) => {
        this.plugin.settings.convertSvgToBitmap = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Embed external images").setDesc(
      "If checked, external images are downloaded and embedded. If unchecked, the resulting document may contain links to external resources"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.embedExternalLinks).onChange(async (value) => {
        this.plugin.settings.embedExternalLinks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Render code with tables").setDesc(
      "If checked code blocks are rendered as tables, which makes pasting into Google docs somewhat prettier."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.formatCodeWithTables).onChange(async (value) => {
        this.plugin.settings.formatCodeWithTables = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Render callouts with tables").setDesc(
      "If checked callouts are rendered as tables, which makes pasting into Google docs somewhat prettier."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.formatCalloutsWithTables).onChange(async (value) => {
        this.plugin.settings.formatCalloutsWithTables = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Rendering" });
    new import_obsidian.Setting(containerEl).setName("Remove properties / front-matter sections").setDesc(
      "If checked, the YAML content between --- lines at the front of the document are removed. If you don't know what this means, leave it on."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.removeFrontMatter).onChange(async (value) => {
        this.plugin.settings.removeFrontMatter = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Remove dataview metadata lines").setDesc(
      _CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML(`
				<p>Remove lines that only contain dataview meta-data, eg. "rating:: 9". Metadata between square brackets is left intact.</p>
				<p>Current limitations are that lines starting with a space are not removed, and lines that look like metadata in code blocks are removed if they don't start with a space</p>`)
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.removeDataviewMetadataLines).onChange(async (value) => {
        this.plugin.settings.removeDataviewMetadataLines = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Footnote handling").setDesc(
      _CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML(`
				<ul>
				  <li>Remove everything: Remove references and links.</li>
				  <li>Display only: leave reference and foot-note, but don't display as a link.</li> 
				  <li>Display and link: attempt to link the reference to the footnote, may not work depending on paste target.</li>
				</ul>`)
    ).addDropdown(
      (dropdown) => dropdown.addOption(
        0 /* REMOVE_ALL */.toString(),
        "Remove everything"
      ).addOption(
        2 /* REMOVE_LINK */.toString(),
        "Display only"
      ).addOption(
        1 /* LEAVE_LINK */.toString(),
        "Display and link"
      ).setValue(this.plugin.settings.footnoteHandling.toString()).onChange(async (value) => {
        switch (value) {
          case 3 /* TITLE_ATTRIBUTE */.toString():
            this.plugin.settings.footnoteHandling = 3 /* TITLE_ATTRIBUTE */;
            break;
          case 0 /* REMOVE_ALL */.toString():
            this.plugin.settings.footnoteHandling = 0 /* REMOVE_ALL */;
            break;
          case 2 /* REMOVE_LINK */.toString():
            this.plugin.settings.footnoteHandling = 2 /* REMOVE_LINK */;
            break;
          case 1 /* LEAVE_LINK */.toString():
          default:
            this.plugin.settings.footnoteHandling = 1 /* LEAVE_LINK */;
            break;
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Link handling").setDesc(
      _CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML(`
				This option controls how links to Obsidian documents and tags are handled.
				<ul>
				  <li>Don't link: only render the link title</li>
				  <li>Open with Obsidian: convert the link to an obsidian:// URI</li> 
				  <li>Link to HTML: keep the link, but convert the extension to .html</li>
				  <li>Leave as is: keep the generated link</li>	
				</ul>`)
    ).addDropdown(
      (dropdown) => dropdown.addOption(
        0 /* CONVERT_TO_TEXT */.toString(),
        "Don't link"
      ).addOption(
        1 /* CONVERT_TO_OBSIDIAN_URI */.toString(),
        "Open with Obsidian"
      ).addOption(
        2 /* LINK_TO_HTML */.toString(),
        "Link to HTML"
      ).addOption(
        3 /* LEAVE_AS_IS */.toString(),
        "Leave as is"
      ).setValue(
        this.plugin.settings.internalLinkHandling.toString()
      ).onChange(async (value) => {
        switch (value) {
          case 1 /* CONVERT_TO_OBSIDIAN_URI */.toString():
            this.plugin.settings.internalLinkHandling = 1 /* CONVERT_TO_OBSIDIAN_URI */;
            break;
          case 2 /* LINK_TO_HTML */.toString():
            this.plugin.settings.internalLinkHandling = 2 /* LINK_TO_HTML */;
            break;
          case 3 /* LEAVE_AS_IS */.toString():
            this.plugin.settings.internalLinkHandling = 3 /* LEAVE_AS_IS */;
            break;
          case 0 /* CONVERT_TO_TEXT */.toString():
          default:
            this.plugin.settings.internalLinkHandling = 0 /* CONVERT_TO_TEXT */;
            break;
        }
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Exotic / Developer options" });
    new import_obsidian.Setting(containerEl).setName("Don't embed images").setDesc(
      "When this option is enabled, images will not be embedded in the HTML document, but <em>broken</em> links will be left in place. This is not recommended."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.disableImageEmbedding).onChange(async (value) => {
        this.plugin.settings.disableImageEmbedding = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
// Thank you, Obsidian Tasks !
_CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML = (html) => createFragment(
  (documentFragment) => documentFragment.createDiv().innerHTML = html
);
var CopyDocumentAsHTMLSettingsTab = _CopyDocumentAsHTMLSettingsTab;
var DEFAULT_SETTINGS = {
  removeFrontMatter: true,
  convertSvgToBitmap: true,
  embedExternalLinks: false,
  removeDataviewMetadataLines: false,
  formatCodeWithTables: false,
  formatCalloutsWithTables: false,
  footnoteHandling: 2 /* REMOVE_LINK */,
  internalLinkHandling: 0 /* CONVERT_TO_TEXT */,
  bareHtmlOnly: false,
  disableImageEmbedding: false
};
var CopyDocumentAsHTMLPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    const beforeAllPostProcessor = this.registerMarkdownPostProcessor(
      async () => {
        ppIsProcessing = true;
      }
    );
    beforeAllPostProcessor.sortOrder = -1e4;
    const afterAllPostProcessor = this.registerMarkdownPostProcessor(
      async () => {
        ppLastBlockDate = Date.now();
        ppIsProcessing = false;
      }
    );
    afterAllPostProcessor.sortOrder = 1e4;
    this.addSettingTab(new CopyDocumentAsHTMLSettingsTab(this.app, this));
    this.setupEditorMenuEntry();
    this.registerDomEvent(document, "copy", (evt) => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView) {
        evt.preventDefault();
        this.copy();
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async copy() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) {
      console.log("Nothing to copy: No active markdown view");
      return false;
    }
    await this.copyFromView(activeView);
    return true;
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async copyFromView(activeView) {
    if (!activeView.editor) {
      console.error("No editor in active view, nothing to copy");
      return;
    }
    if (!activeView.file) {
      console.error("No file in active view, nothing to copy");
      return;
    }
    const markdown = activeView.editor.getSelection() || activeView.data;
    const path = activeView.file.path;
    const name = activeView.file.name;
    return this.doCopy(markdown, path, name);
  }
  async copyFromFile(file) {
    if (!(file instanceof import_obsidian.TFile)) {
      console.log(`cannot copy folder to HTML: ${file.path}`);
      return;
    }
    if (file.extension.toLowerCase() !== "md") {
      console.log(`cannot only copy .md files to HTML: ${file.path}`);
      return;
    }
    const markdown = await file.vault.cachedRead(file);
    return this.doCopy(markdown, file.path, file.name);
  }
  async doCopy(markdown, path, name) {
    console.log(`Copying "${path}" to clipboard...`);
    const title = name.replace(/\.md$/i, "");
    const copier = new DocumentRenderer(this.app, this.settings);
    try {
      copyIsRunning = true;
      ppLastBlockDate = Date.now();
      ppIsProcessing = true;
      const htmlBody = await copier.renderDocument(markdown, path);
      const htmlDocument = htmlBody.outerHTML;
      const data = new ClipboardItem({
        "text/html": new Blob([htmlDocument], {
          // @ts-ignore
          type: ["text/html", "text/plain"]
        }),
        "text/plain": new Blob([markdown], {
          type: "text/plain"
        })
      });
      await navigator.clipboard.write([data]);
      console.log(`Copied to clipboard as HTML`);
      new import_obsidian.Notice(`Copied to clipboard as HTML`);
    } catch (error) {
      new import_obsidian.Notice(`copy failed: ${error}`);
      console.error("copy failed", error);
    } finally {
      copyIsRunning = false;
    }
  }
  setupEditorMenuEntry() {
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file, view) => {
        menu.addItem((item) => {
          item.setTitle("Copy as HTML").setIcon("clipboard-copy").onClick(async () => {
            return this.copyFromFile(file);
          });
        });
      })
    );
  }
};
