# LayoutNG block fragmentation

Morten Stenshorne \<[mstensho@chromium.org](mailto:mstensho@chromium.org)\>, April \- October 2019

[Fragmentation is hard.](https://www.youtube.com/watch?v=pQHX-SjgQvQ) :)

This document contains some rough estimates. They are in calendar time, assuming that the work is to be carried out by a developer who is generally 50% busy doing other things (code reviews, P1 bugs, etc.)

While inline fragmentation is about breaking and flowing boxes in an inline formatting context into line boxes (i.e. lines of text and other inline elements), block fragmentation is about breaking and flowing boxes in a block formatting context (and usually all nested block formatting contexts inside it) into pages or columns \- generically referred to as *fragmentainers*.  
Two features in Chromium use block fragmentation: [multicol](https://www.w3.org/TR/css-multicol-1/), and [pagination for printing](https://www.w3.org/TR/css-page-3/).

The block fragmentation spec is here: [https://www.w3.org/TR/css-break-3/](https://www.w3.org/TR/css-break-3/)

LayoutNG is designed with fragmentation (both inline and block fragmentation) in mind, allowing for a sensible implementation, as opposed to our legacy engine, where both inline and block fragmentation were pretty much duct-taped to the side of a purely CSS-box-centric implementation. Internally, for block fragmentation, the legacy layout engine doesn’t really understand anything about fragments at all. All blocks are just simple (possibly tall) rectangular objects, even if a block happens to cross a fragmentainer boundary. The legacy engine knows the block-size of the fragmentainer, and it keeps track of how far from the block-start of the current fragmentainer it is laying out at. If some unbreakable content needs to be pushed to the next fragmentainer because it cannot fit in the previous one, the legacy engine just inserts a so-called *pagination strut* before the outer block-start edge of the object (or line box), so that, when the single rectangle would eventually be sliced into fragments, the object or line box would appear exactly at the block-start of the next fragmentainer. Actual fragmentation (the slicing) takes place when performing read operations on the layout tree (such as painting, hit-testing, or certain DOM APIs, like Element.offsetTop). This makes many things hard or impossible, such as correct overflow handling, relative-positioning, and transforms.

LayoutNG is different. It’s aware of fragmentation. Fragmentation is a first-class citizen. It produces actual fragments for each CSS box. If a box lives in three columns, there’ll be three fragments for it. No stitching or slicing will be required \[\*\]. Painting and hit-testing won’t have to figure out where one fragment starts and ends, and where it is positioned.

\[\*\] The initial proof-of-concept implementation wrote fragment data back to the legacy LayoutFlowThread implementation, in order to paint and hit-test, since that wasn’t yet supported by the NG fragment painting code. This involved stitching the NG fragments together into one tall rectangle per CSS box, since that’s how the legacy engine needs it.

The NG block fragmentation implementation is currently behind a runtime flag named LayoutNGBlockFragmentation (not enabled by default anywhere).

LayoutNG takes a CSS box as input and generates one or more fragments from it. A CSS box is referred to as a *node* (NGLayoutInputNode) in the NG implementation.

## Break tokens

In order for LayoutNG to generate multiple fragments (NGPhysicalFragment) from a single CSS box (NGLayoutInputNode), it needs a way of aborting layout when one fragmentainer cannot take more content without overflowing (or without unnecessarily violating other rules, such as orphans/widows requirements, or break-{after,before,inside}:avoid). This is what break tokens are for. A break token (NGBlockBreakToken) will be created when we have decided to stop filling the current fragmentainer (and continue in the next). It is used to resume layout at the correct offsets in the (nested) fragmented boxes in the next fragmentainer.

This is similar to what we’re already shipping for inline fragmentation, where we create a break token (NGInlineBreakToken) at the end of each line, so that we know where in the content to resume when creating the next line, including which inline boxes we’re inside, so that the text gets the right color, font face, size, weight, slant, and so on.

We create break tokens for a fragment when there’s more content to consume in the node afterwards, i.e. when it breaks. Final fragments don’t get a break token.

We store the amount of space consumed (laid out) in previous fragmentainers in the break tokens for each node, as a block-offset into said node, so that we know exactly how much we need to skip when resuming layout in the next fragment.

When resuming layout, we first handle incoming break tokens from the previous fragmentainer. Then we resume at the next sibling node of the one associated with the last break token \- unless we have already walked past all children in a previous fragmentainer. That situation may arise when there’s something tall that fragments, followed by something that doesn’t fragment (so that everything that followed the tall thing that fragmented will actually fit in the fragmentainer).

LayoutNG has special layout algorithms to drive the flow of content from one fragmentainer to the next, and to produce fragments for the fragmentainers themselves.

| Example: \<div id="mc" style="columns:3; column-fill:auto; height:100px;"\>   \<div id="foo" style="height:70px; background:yellow;"\>\</div\>   \<div id="bar" style="height:200px; background:blue;"\>\</div\> \</div\>  ![][image1] Inside \#mc, we create a column layout algorithm. For each column, we create an anonymous block layout algorithm, and traverse the children. All of \#foo will fit in the first column (fragmentainer). We create a 70px tall fragment, with no break token. Only 30px of \#bar will fit in the first column. We create a 30px tall fragment, and a break token, noting that we have only processed 30px of the content (in other words, block-offset at which to resume in the next fragmentainer: 30px). Then we abort, by creating a 100px tall fragment for the first column, along with a break token that says that we’re at block offset 100px in the column contents. When we lay out the second column, we start with the first and only break token, the one for \#bar. There we resume at block offset 30px. We still have 200px \- 30px \= 170px left to process, but only room for 100px. We create a 100px tall fragment, along with a break token that says that we’ve processed 30px+100px=130px of content. Then we abort again, by creating a 100px tall fragment for the second column, along with a break token that says that we’re now at block offset 200px. When we lay out the third column, there’s a break token for \#bar again. We resume at block offset 130px, and create a fragment for the remaining 70px, and this time we won’t need a break token, since we managed to lay out everything. Then we create a 70px tall fragment for the third column. Break token structure for the first column fragment: NGBlockBreakToken for column, at offset 100px   NGBlockBreakToken for \#bar, at offset 30px  Break token structure for the second column fragment: NGBlockBreakToken for column, at offset 200px   NGBlockBreakToken for \#bar, at offset 130px  No break tokens are produced for the third column fragment.  Fragment structure: \#mc, 100px tall   First column, 100px tall     \#foo fragment, 70px tall     \#bar fragment, 30px tall   Second column, 100px tall     \#bar fragment, 100px tall   Third column, 70px tall     \#bar fragment, 70px tall |
| :---- |

When resuming layout in a subsequent fragmentainer, we traverse the break token structure along with the node structure, to figure out which nodes to (re-)visit. When traversing children of a node, we first go through all the break tokens, and resume layout of those nodes. Then we continue with the nodes following the one associated with the last break token, unless we know that we’ve already processed all children except for the fragmented ones.

When something breaks, we need to create a break token for each containing fragment all the way up to the node that establishes the fragmentation context. When a descendant needs to break and resume, so do the ancestors. We need a break token for each node in the ancestry chain, so that we know which nodes to revisit and at which offset to resume within each of them. The previous example demonstrates this.

| Example: \<div id="mc" style="columns:2; column-fill:auto; height:100px;"\>   \<div id="outer"\>     \<div id="foo" style="height:70px; background:yellow;"\>\</div\>     \<div id="bar" style="height:70px; background:blue;"\>\</div\>   \</div\> \</div\>  ![][image2] In the first column we lay out \#outer, and descend into the children. First we get to \#foo. We create a 70px tall fragment, but no break token, since everything fits. Then we continue with \#bar. Here we run out of space. We create a 30px tall fragment for \#bar, along with a break token with consumed block-size of 30px. When we return to \#outer, we notice that we have broken, so we need to break \#outer as well. It gets a 100px tall fragment, and a break token at block offset 100px. The break tokens for \#foo and \#bar will be children of the break token for \#outer. Then we abort layout of the first column, by creating a 100px tall fragment for the column, along with a break token that says that we’re at 100px. The break token created for \#outer will be a child of this break token. In the second column, we find the break token for \#outer, and resume at block offset 100px. We descend into the children. We find a break token for \#bar, which is at consumed block-offset 30px. We process the rest, which fits. We create a 40px tall fragment and no break token. We return to \#outer, since there are no more children. We create a 40px tall fragment for \#outer, but no break token. Then we create a 40px tall fragment for the second, and no break token for that one, either. Break token structure for the first column fragment: NGBlockBreakToken for column, at offset 100px   NGBlockBreakToken for \#outer, at offset 100px     NGBlockBreakToken for \#bar, at offset 30px  No break tokens are produced for the second column fragment.    |
| :---- |

| Another example, where the outer node is overflowed: \<div id="mc" style="columns:2; column-fill:auto; height:100px;"\>   \<div id="outer" style="height:50px; background:hotpink;"\>     \<div id="foo" style="width:90%; height:70px; background:yellow;"\>\</div\>     \<div id="bar" style="width:90%; height:70px; background:blue;"\>\</div\>   \</div\> \</div\>  ![][image3]  In the first column we lay out \#outer, and descend into the children. First we get to \#foo. We create a 70px tall fragment. No break token needed, since we’re finished. Then we continue with \#bar. Here we run out of space. We create a 30px tall fragment for \#bar, along with a break token with consumed block-size 30px. When we return to \#outer, we notice that we have broken, so we need to break \#outer as well. Due to its restricted height, it gets a 50px tall fragment (although there’s 100px of content inside), and a break token at block-offset 50px. Then we abort layout of the first column, by creating a 100px tall fragment for the first column, along with a break token at offset 100px. In the second column, we find the break token for \#outer, and resume at block offset 50px. We descend into the children. We find a break token for \#bar, which is at block-offset 30px. We process the rest, which fits. We create a 40px tall fragment, with no break token. We return to \#outer, since there are no more children. We create a 0px tall fragment for \#outer. We create a 0px tall fragment for the second column. Break token structure for the first column fragment: NGBlockBreakToken for column, at offset 100px   NGBlockBreakToken for \#outer, at offset 50px     NGBlockBreakToken for \#bar, at offset 30px  No break tokens are produced for the second column fragment. Fragment structure: \#mc, 100px tall   First column, 100px tall     \#outer fragment, 50px tall       \#foo fragment, 70px tall       \#bar fragment, 30px tall   Second column, 0px tall     \#outer fragment, 50px tall       \#bar fragment, 40px tall |
| :---- |

There may be several break tokens at each fragmentainer boundary, typically one per *flow*. There may be parallel flows, which are caused by floats, visible overflow in the block direction, table cells, flex items, out-of-flow positioned boxes, and so on.

| Example: \<div id="mc" style="columns:2; column-fill:auto; height:100px;"\>   \<div id="foo" style="float:left; width:50px; height:120px; background:yellow;"\>\</div\>   \<div id="bar" style="height:150px; background:blue;"\>\</div\> \</div\>  ![][image4]  In the first column, we create a 100px tall fragment for \#foo, and a break token for it that says that we’re at offset 100px. \#foo is floated, and we cannot abort, since there’s a parallel flow for the in-flow content represented by \#bar. We can also fit 100px of \#bar, and create a break token for it that says that we broke at offset 100px. Now we can finish layout of the first column, since there are no other flows to examine. We create a 100px tall fragment for the first column, along with a break token at offset 100px. When we lay out the second column, we have a break token for \#foo, and resume at offset 100px, so that we create a 20px tall fragment. We also have a break token for \#bar, and we resume at block offset 100px. We create a 50px tall fragment. Finally, we create a 50px tall fragment for the second column. Break token structure for the first column fragment: NGBlockBreakToken for column, at offset 100px   NGBlockBreakToken for \#outer, at offset 50px     NGBlockBreakToken for \#foo, at offset 100px     NGBlockBreakToken for \#bar, at offset 100px  No break tokens are produced for the second column fragment. |
| :---- |

Block fragmentation interacts with inline fragmentation. If we need a fragmentainer break in the middle of an inline formatting context, we nest an inline break token inside of a block break token, so that we know where to resume after the fragmentainer break.

| Example: \<div id="mc" style="columns:2; column-fill:auto; height:100px;"\>   \<div id="outer" style="line-height:50px; background:papayawhip;"\>     Line 1\<br\>     Line 2\<b\>bold\<br\>     Line 3\</b\>   \</div\> \</div\>  ![][image5]  In the first column we lay out \#outer, and start laying out its lines. We fit 2 lines. The inline layout algorithm produces an inline break token for each line, which contains information about which text node we’re in, what character offset, and some more state, to make sure that we resume correctly (one important detail is that we’re inside a \<b\> element). \#outer will produce a 100px tall fragment for itself, along with a block break token, noting that it has processed 100px of content. The inline break token will be a child of this block break token. Then we abort layout of the first column, by creating a block break token for the column itself, at offset 100px, which will be wrapped around the previously created break tokens. In the second column, we find the break token for \#outer, and resume at block offset 100px.  Inside we find the inline break token, and resume line layout, which is outside the scope of this document (but somehow the text obviously has to be bold). After finishing the third line, there’s nothing left, and we can create a 50px tall fragment for \#outer. We’re done with the fragmentation context, and create a 50px tall fragment for the column itself. |
| :---- |

## Nested fragmentation contexts

Multicol containers will establish a nested fragmentation context when said multicol container participates in an outer fragmentation context (established by e.g. printing, or by another, outer, multicol container).

If the block-size of an inner multicol container is larger than what can fit in the outer fragmentainer, it will use all available space in the outer fragmentainer, and when we have reached the [used value of column-count](https://www.w3.org/TR/css-multicol-1/#pseudo-algorithm), instead of creating overflowing columns in the inline direction, we finish the row of columns, and continue with a new row of columns in the next outer fragmentainer. We’ll produce break tokens in the inner fragmentation context that will be propagated to the outer one, so that we know where to resume in the next outer and inner fragmentainers.

| Example: \<div id="outermc" style="columns:2; column-fill:auto; height:100px; background:pink;"\>   \<div id="foo" style="height:60px; background:yellow;"\>\</div\>   \<div id="innermc" style="columns:2; column-fill:auto; height:100px; background:hotpink;"\>     \<div id="bar" style="height:70px; background:blue;"\>\</div\>     \<div id="hest" style="height:110px; background:cyan;"\>\</div\>   \</div\> \</div\>  ![][image6]  We lay out the first outer column (established by \#outermc), and place \#foo there. It fits. We create a 60px tall fragment, with no break token. Now we enter \#innermc. It’s taller than what we have space left in the first column. We only have 40px left at this point, so that will be the height of the first inner row of columns. We lay out the first inner column. We create a 40px tall fragment for \#bar, along with a break token with consumed block-size of 40px. We create a 40px tall fragment for the inner column to put the \#bar fragment inside, and a break token with block offset 40px. We continue in the second inner column. We create a fragment for the remaining 30px of \#bar. Then we get to \#hest. We have 10px left in the second inner column, so we create a 10px tall fragment for \#hest, along with a break token at block-offset 10px. We wrap this inside a 40px tall fragment for the second inner column, along with a break token at block offset 80px. We have now filled both inner columns, but there’s more content. We create a 40px tall fragment for \#innermc, along with a break token at block offset 40px. Then we create a 100px tall fragment for the first outer column, and wrap it around the other fragments we’ve created. We create a break token for the outer column, at block offset 100px. We’re ready to lay out the second outer column. We’ll resume at \#innermc, block offset 40px. The height of \#innermc is 100px. We have already processed 40px of it, so the second row for inner columns will be 60px tall. Column layout in \#innermc will resume at offset 80px. We’ll create another fragment for \#hest here. It will be 60px tall (since that’s the height of the row), and there’ll be a break token at block offset 70px (we have already placed 10px of \#hest in the first outer column). We create a 60px tall fragment for the first inner column (in the second row), with a break token at offset 140px. We resume in the second inner column (in the second row). We create a 40px tall fragment for \#hest, since that’s all what remains. This is wrapped inside a 40px tall fragment for the second inner column (in the second row). We create a 60px tall fragment for \#innermc. Then we create a 60px tall fragment for the second outer column. Finally, we create a 100px tall fragment for \#outermc. Break token structure for the first outer column fragment: NGBlockBreakToken for \#outermc column, at offset 100px   NGBlockBreakToken for \#innermc, at offset 40px     NGBlockBreakToken for first inner column, at offset 40px       NGBlockBreakToken for \#bar, at offset 40px     NGBlockBreakToken for second inner column, at offset 80px       NGBlockBreakToken for \#hest, at offset 10px There will be no break token produced for the second outer column fragment, but the first inner column will need:     NGBlockBreakToken for first inner column, at offset 140px       NGBlockBreakToken for \#hest, at offset 70px  Fragment structure: \#outermc, 100px tall   First \#outermc column, 100px tall     \#foo, 60px tall     \#innermc, 40px tall (creates the first row for columns)       First \#innermc column, 40px tall         \#bar, 40px tall       Second \#innermc column, 40px tall         \#bar, 30px tall         \#hest, 10px tall   Second \#outermc column, 60px tall     \#innermc, 60px tall (creates the second row for columns)       First \#innermc column, 60px tall         \#hest, 60px tall       Second \#innermc column, 40px tall         \#hest, 40px tall |
| :---- |

Implementation status (October 2019): Done, but we still don’t support nested column balancing (multicol container with column-fill:balance inside multicol container with column-fill:balance). See separate paragraph for estimate.

## Fragmentainer breaks

[https://www.w3.org/TR/css-break-3/\#breaking-rules](https://www.w3.org/TR/css-break-3/#breaking-rules)

There are many possible break points, and they are divided into three classes (or types; there is no inherent prioritization among these classes of break points \- they are just different types):  
A: **Between** sibling blocks (but **not** before a first child block or after a last child block)  
B: **Between** line boxes (but **not** before a first line or after a last line in a block)  
C: Between the content edge of a block and its first in-flow child, if there’s a gap there (e.g. caused by a float taking up all available inline space, so that the first line of text ends up below it)

For lines, i.e. class B breakpoints, we will try to honor orphans and widows requirements when considering whether or not to break between lines. Those requirements are specified via the “orphans” and “widows” CSS properties (applied on the container).

All other break considerations regard non-inline CSS boxes (typically block containers, but also e.g. tables, table rows, flex containers). We can force breaks at class A and C break points, using “forced” values (such as “column”, “page”, “left”, “right”) on the “break-before” and “break-after” properties. The same properties can also be used to attempt to prevent breaks between boxes (the “avoid” value, for instance). In addition, there’s a “break-inside” property, which can be used to avoid breaking inside a box. The initial values of these properties are “auto”, which means that we may break if we need to. Roughly speaking, “forced” break definitions take precedence over “avoid” definitions, which in turn take precedence over auto definitions. All the definitions apply to the nearest valid breakpoint, and are propagated to that breakpoint. If break-before:page is specified on a first-child block, for instance, it will be propagated up the ancestry chain until a valid break point is found.

| Example: \<div style="columns:2;"\>   \<div id="a"\>\</div\>   \<div id="b"\>     \<div id="c"\>       \<div id="d" style="break-before:column;"\>\</div\> We will not insert a break before \#d here, since it’s a first child, and therefore not a valid breakpoint (need to be between something). We’ll propagate the definition to \#c, but we can’t break before \#c, either, for the same reasons. We propagate it to \#b, and that’s a valid class A breakpoint, since it has a preceding sibling. We’ll break before \#b, i.e. between \#a and \#b. Similar for break-after: \<div style="columns:2;"\>   \<div id="a"\>\</div\>   \<div id="b"\>     \<div id="c"\>       \<div id="d" style="break-after:column;"\>\</div\>     \</div\>   \</div\>   \<div id="e"\>\</div\> \</div\> We will not insert a break after \#d here, since it’s a last child, and therefore not a valid breakpoint. We’ll propagate the definition to \#c, but we can’t after before \#c, either, for the same reasons. We propagate it to \#b, and that’s a valid class A breakpoint, since it has a preceding sibling. We’ll break after \#b, i.e. between \#b and \#e. |
| :---- |

The NG implementation handles this propagation by setting an initial break-before and a final break-after value in NGLayoutResult, which will be propagated up the ancestry until a valid breakpoint is found.

When we eventually find that valid spot, we’ll create a break token for the node that we want to break before. In other words, a break-after definition is also treated as breaking before something. This will take place before we have created any fragments at all for the node, since its first fragment needs to be in the next fragmentainer, because of the forced break.

If we don’t find a valid spot, it means that we have reached the beginning or the end of the fragmentation context, in which no forced break will be inserted.

Implementation status (October 2019): Done, except that we don't distinguish between different types of forced breaks, which matters for printing (break to the next page, break to the next left page, break to the next right page).  
Estimate: 1 week (but kind of blocked on printing and fragment painting support, unless we want to improve the test frameworks for printing, which would take longer)

### Determination of unforced breaks

There are some rules that determine which breakpoint to pick over others. First of all, we should attempt to fit as much content as possible within each fragmentainer, but at the same time attempt to honor orphans/widows requirements, and break-{after,before,inside}:avoid. If there are not enough break points (without overflowing the fragmentainer) after taking all these things into consideration, we’ll start dropping rule after rule. First we’ll ignore orphans/widows requirements. If that’s still not good enough, we’ll ignore break-{after,before,inside}:avoid declarations (the spec doesn’t say which of the ‘avoid’ declarations to ignore before others). If that’s still not good enough, we may truncate cloned margins/borders/padding at fragmentainer boundaries. If even that isn’t good enough, we may break wherever, but still attempt to avoid it inside monolithic content (such as line boxes or images).

No matter where we break, there’s one important rule: We need some progress (and if that involves violating all the aforementioned rules, so be it) before we break. Breaking at the very block-start of a fragmentainer is not allowed, as that would typically mean that we’d create an infinite number of fragmentainers, getting nowhere with the contents.

To determine where to put the unforced breaks, we need to keep track of the best break location candidate (so far) during layout. The candidate we’re left with when finally running out of space is where we should break. During layout, every time we find a possible break location, we should determine how appealing it is. If it’s at least as appealing as the one we’ve already found (if any), we should keep track of this possible break point, and carry on, until we run out of space. We’ll store this information in the fragment builder while working inside one and the same container, but when we need to propagate this to a parent, child, or sibling, we’ll also need to store it in NGLayoutResult (output), and the highest appeal of any breakpoint so far will even be stored in NGConstraintSpace (input), so that we know the minimum appeal, so that we can disregard less appealing breakpoints.

We may actually even need to continue laying out a bit past the point we went out of space, to see if there are any widows requirements that we can honor; see the chapter about orphans and widows.

We score each possible break location that we come across, to determine how appealing it is; e.g.:

(higher is better)  
1: Can break without fragmenting monolithic content (last resort, not a valid breakpoint)  
2: Can break without violating break-{after,before,inside}:avoid declarations  
3: Can break without violating orphans / widows

We should only update the possible early breakpoint if we come across one that has the same score/appeal or higher than the one we already have. This way we’ll fit as much content as possible, violating as few rules as possible.

The box fragment builder doesn’t support roll-back to an earlier state, so if we decide to use an earlier breakpoint, rather than the one we’re at when we run out of space, we will have to re-layout, and break at said earlier breakpoint. If the earlier breakpoint is in the same container as the one we’re inside when running out of space, this is relatively simple. But this may not always be the case:

| Example: \<div style="columns:2; column-fill:auto; height:90px;"\>   \<div id="foo"\>     \<div style="height:20px; break-inside:avoid;"\>\</div\>     \<div style="height:20px; break-inside:avoid;"\>\</div\>     \<div style="height:20px; break-inside:avoid;"\>\</div\>   \</div\>   \<div id="bar" style="break-before:avoid; break-inside:avoid;"\>     \<div style="height:20px; break-inside:avoid;"\>\</div\>     \<div style="height:20px; break-inside:avoid;"\>\</div\>   \</div\> \</div\> We have 5 pieces of break-inside:avoid blocks, each 20px tall. With a column height of 90px, we should be able to fit four in one column. We want to avoid breaking before \#foo (because of break-before:avoid), and also inside it (because of break-inside:avoid). We run out of space before the second child of \#bar. Before we’ve got so far, we have analyzed earlier breakpoints: Between the first two children of \#foo. That’s a perfect breakpoint. No restrictions there. The same goes for breaking between the two last children of \#foo. That’s also a perfect breakpoint, meaning that we’ll prefer that one over breaking between the first two children, since it takes it further through the content. This means that if we are to break inside \#foo, breaking between its two last children would be perfect. But we’re still not out of space, so we continue. When we run out of space inside \#bar, between its two children, we’ll calculate the appeal of just breaking there. There are no restrictions on breaking between them, but there’s a break-avoid restriction on breaking inside \#bar. This will decrease the appeal of breaking there. Breaking before \#bar isn’t great either, because we’d violate the break-before:avoid rule. So, in the end, we decide to break between the two last children of \#foo. This means that we need to abort and re-layout \#foo (we initially made all its children fit, but it turned out we have to break before the last one). |
| :---- |

Implementation status (October 2019): Done

## Orphans and widows

[https://www.w3.org/TR/css-break-3/\#widows-orphans](https://www.w3.org/TR/css-break-3/#widows-orphans)

Orphans and widows specify the minimum number lines of a block that are allowed to occur before (orphans) or after (widows) a fragmentainer break.  
In order to honor orphans and widows, we may need to lay out more lines that can fit in the current fragmentainer before aborting and creating a break token. To honor widows, we may have to abort layout and relayout to create a break token at an earlier position, even though more lines could fit in the previous fragmentainer.

| Example: \<div style="columns:2; column-fill:auto; orphans:1; widows:3; height:100px; line-height:20px; background:navajowhite;"\>   Line 1\<br\>   Line 2\<br\>   Line 3\<br\>   Line 4\<br\>   Line 5\<br\>   Line 6\<br\>   Line 7\<br\> \</div\>  ![][image7]  We have 7 lines. They are 20px tall each. The column height is 100px, so 5 lines could in theory fit in a column. When we run out of space in the first column, i.e. when attempting to place line 6, we need to keep going to examine the situation, in order to make sure that there will be enough lines in the second column to honor the widows requirement (if at all possible \- and it is in this case). We lay out line 7 to figure out that we’ve reached the end of the container. Then we realize that we need to break after line 4 (although line 5 would fit too), so that the lines 5 to 7 go into the second column, honoring the widows requirement of 3 lines. |
| :---- |

Implementation status (October 2019): Done

## Out-of-flow positioning

(07/08/2020) An updated version of the design doc for out-of-flow positioned elements can be found [here](https://docs.google.com/document/d/1DE8ZJg_8IMZhwj9809eINKyDnNL5ysv6zd2lObC4t30/edit?usp=sharing).

**TODO: delete or merge the rest of this chapter into the document above**

If an out-of-flow (OOF) positioned descendant is contained by the fragmentation context (either because the box that establishes the fragmentation context itself also establishes an OOF containing block, or a descendant does it (e.g. via position:relative), the OOF may get fragmented too, just like any other node in a fragmentation context.

NGOutOfFlowLayoutPart needs to set up a correct NGConstraintSpace for fragmentation, and also pass the break token when laying out subsequent fragments.

OOFs that have auto block-offset (i.e. hypothetically-statically positioned in the block direction, i.e. when both top and bottom are auto in horizontal writing-mode) should be rather straight-forward to deal with. During layout of their first fragment they bubble up the normal way (and get their offset calculated on the way) to the containing block, and can get laid out normally, and create a break token if everything cannot fit.

For OOFs that have a non-auto block-offset, it gets a bit more complicated. The most difficult case is when the block-start offset is auto, but its block-end offset isn't (“bottom-aligned”). Then we'd need to lay out all the fragments of its containing block, in order to find the size of the containing block. Only then can we calculate the start offset for the OOF. This offset may be in an earlier fragmentainer, so we're going to need a multi-pass layout (one additional pass per nesting level (i.e. bottom aligned inside bottom aligned)) of the fragmentation context to correctly position and lay out OOFs (where all the passes but the first will be some sort of a "simplified" layout pass).

Alternative solution: If we ignore "bottom-aligned" OOFs, or at least require them to start in the same fragmentainer as the one their containing block ends in, we could deal with everything in one pass, but we'd still have to scan the entire fragmentation context in the first fragmentainer and look for "top-aligned" OOFs and create break tokens for them, without producing any fragments (kind of similar to what we already do for forced fragmentainer breaks, only slightly more sophisticated; we'd need to keep track of how much block offset we have left to consume before we can start laying out). An OOF may be the last element in the DOM, for instance, following lots of in-flow content, split into multiple fragmentainers \- but if their "top" property is e.g. 0px, it needs to start inside the first fragment of its containing block. Not detecting this OOF until we get to a subsequent fragment of the containing block would be too late, unless we want multi-pass.

Implementation status (June 2019): Not started.  
Estimate is difficult until we settle on a solution.

## Cloned borders and padding

This is about implementing box-decoration-break:clone for block fragmentation. The spec also mentions cloned margins, but this isn’t relevant for block fragmentation, since margins are truncated at fragmentainer boundaries.

This isn’t supported in the Blink legacy engine, but seems to be a wanted feature. One tricky part of the job will be to drop cloned borders and padding as needed to provide better breakpoints, when space is too restricted to find any good ones with them cloned.

Implementation status (October 2019): Not started

## Multicol-specific functionality

There’s a specific NG layout algorithm that creates a fragment for each column and flows content into those.

### Column spanners

Not strictly a block fragmentation concept, but rather one that causes block fragmentation to be interrupted (at the innermost multicol container), and resumed again when we’re done with the spanner.

This should be fairly straight-forward to implement in LayoutNG. Some extra care is required to make sure that we don’t allow spanners where they shouldn’t be allowed. [According to the spec](https://www.w3.org/TR/css-multicol-1/#valdef-column-span-all), spanners are only allowed if they live in the same block formatting context as the one established by the multicol container, mainly due to implementation difficulties (that might actually not be that difficult at in LayoutNG, though). We need some mechanism (a flag in the NGConstraintSpace or something like that) to tell if we’re in the right initial formatting context of the multicol container or not. And, when stumbling into the spanner during layout, we need to create a special break token for it, so that NGMultiColumnLayoutAlgorithm knows what to do.

Implementation status (October 2019): Done.

### Column balancing

This is about calculating the block-size of the fragmentainers (columns) automatically, based on the contents. The columns should only be as tall as strictly necessary to avoid creating overflowing columns (more than the [used value of column-count](https://www.w3.org/TR/css-multicol-1/#pseudo-algorithm)) in the inline direction.

Column balancing requires a special layout pass, to calculate the total block-size of the column contents. This pass will just lay out everything in a tall single strip (“column”), and count how many forced breaks we have, and figure out where they are, so that we know how many unforced breaks we need to insert, and where to insert them. After this pass, we have a tentative minimal column block-size. Then we attempt to lay out, and see if it results in overflowing columns (i.e. more columns than [the used value of column-count](https://www.w3.org/TR/css-multicol-1/#pseudo-algorithm)). This happens when there’s monolithic content (e.g. lines) that we cannot freely break inside. If this happens, we need to stretch the column block-size by the *minimum space shortage*. This is a value that we calculate during layout, and it’s the smallest amount of space that we lacked to place some content in the current column.

| Example: \<div style="columns:3; orphans:1; widows:1; line-height:30px; background:navajowhite;"\>   Line 1\<br\>   Line 2\<br\>   Line 3\<br\>   Line 4\<br\>   Line 5\<br\>   Line 6\<br\>   Line 7\<br\> \</div\>  ![][image8]  In the initial balancing layout pass we find that the height of the column contents is 7 \* 30px \= 210px. We have 3 columns, so we divide that number by 3, and get an initial column height of 70px. We then perform normal column layout. We’re able to fit 2 lines (2\*30px \< 70px) in the first column. For a third line to fit there, we’d need a 20px taller column. The same thing happens in the second and third columns. We’ll fit 2 lines in each, and be short of 20px to fit any more. We’re going to need a fourth column for the last line. So we get too many columns, which means that the columns were not tall enough. During layout we found the *minimum space shortage* to be 20px. If the columns were 20px taller, i.e. 90px, we’d be able to fit one more line in each column. So the final balanced column height will be 90px. Anything less will create overflowing columns. |
| :---- |

Implementation status (October 2019): Done, except for support for nested column balancing.   
Remaining estimate: 2 weeks

## Printing-specific functionality

We need a designated NG layout algorithm for pagination (for printing), that creates one fragment per page and flows content into those. When we paginate for printing, it’s the root layout box that gets fragmented. That’s the LayoutView object. We need a LayoutNGView derived class, to get native fragmentation support for printing.  
The layout algorithm also needs to take @page rules into account, in order to produce fragments of variable size and/or orientation, when we want to support that.

Implementation status (October 2019): Not started.  
Estimate: 2 weeks, without adding new functionality (i.e. variable page size / orientation)

## Painting / hit-testing

The initial implementation of NG block fragmentation writes back fragment data to the legacy structures, so that we can paint and hit-test using the legacy painting and hit-testing code, heavily relying on the LayoutMultiColumnFlowThread legacy layout class. The flow thread design is exactly what we need to move away from. We need the NG painting code to paint the fragments, rather than having to fall back to legacy LayoutBox painting. Тhen we can stop creating the LayoutMultiColumnFlowThread, LayoutMultiColumnSet and LayoutMultiColumnSpannerPlaceholder objects. They are just in the way for us anyway. In NG, painting and hit-testing for block fragmentation will be rather painless, since the code won’t have to figure out where in the flow one imaginary fragment starts and ends, and where on the screen it is positioned. We have fragments now. So all we have to do is use them.

Switching over to painting the fragment tree, rather than the layout object tree, is no easy task, and is really just a prerequisite for block fragmentation, and not within the scope of block fragmentation work.

There’s one additional requirement for multicol, though: we need to paint column rules.  
Estimate for that: a day or two

## Coexistence with legacy layout

There are certain layout modes and situations that still makes us fall back to the legacy layout engine, because it hasn’t yet been implemented in LayoutNG. Examples (as of 2019-06-04): tables, flexbox, grid, fieldset, editing, ruby, form controls, replaced content.

The challenge with block fragmentation is that it needs to be supported inside box types (such as table and flexbox) that LayoutNG still doesn’t support natively. In order to be able to ship any part of block fragmentation, we either need to make sure that the legacy and NG block fragmentation can work together, or, make sure that the two fragmentation implementations never meet.

Getting the LayoutNG and the legacy layout engine block fragmentation implementations to cooperate within the same fragmentation context would be attractive in a way, but is rather unrealistic (most likely very complicated and bug-prone).

A more realistic approach could be to force the entire fragmentation context to use legacy layout, if there’s anything inside it at all that cannot be laid out by LayoutNG. We need to be able to detect these situations reliably, though. False positives are okay. False negatives (we end up doing NG block fragmentation with something legacy inside) is NOT.

Status (October 2019): We support falling back the entire fragmentation context to legacy if it contains non-NG layout objects.

[image1]: <data:image/png;base64,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>

[image2]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZ0AAABwCAIAAABKEDodAAAEJklEQVR4Xu3UQWokQAwEwfn/Z/cJ3nupQcJ0CzxEEiedC33+SdJ39cmDJP3x/DVJ35a/Junb8tckfVv+mqRvy1+T9G2d/9rPzwd+LffU9fn8wK/lnvw1Xsg9ddWlwlzuyV/jhdxTV10qzOWe/DVeyD111aXCXO7JX+OF3FNXXSrM5Z78NV7IPXXVpcJc7slf44XcU1ddKszlnvw1Xsg9ddWlwlzuyV/jhdxTV10qzOWe/DVeyD111aXCXO7JX+OF3FNXXSrM5Z78NV7IPXXVpcJc7slf44XcU1ddKszlnvw1Xsg9ddWlwlzuyV/jhdxTV10qzOWe/DVeyD111aXCXO7JX+OF3FNXXSrM5Z78NV7IPXXVpcJc7slf44XcU1ddKszlnvw1Xsg9ddWlwlzuyV/jhdxTV10qzOWe/DVeyD111aXCXO7JX+OF3FNXXSrM5Z78NV7IPXXVpcJc7slf44XcU1ddKszlnvw1Xsg9ddWlwlzuyV/jhdxTV10qzOWe/DVeyD111aXCXO7JX+OF3FNXXSrM5Z78NV7IPXXVpcJc7slf44XcU1ddKszlnvw1Xsg9ddWlwlzuyV/jhdxTV10qzOWe/DVeyD111aXCXO7JX+OF3FNXXSrM5Z78NV7IPXXVpcJc7slf44XcU1ddKszlnvw1Xsg9ddWlwlzuyV/jhdxTV10qzOWe/DVeyD111aXCXO7JX+OF3JO023mCdakwl3uSdjtPsC4V5nJP0m7nCdalwlzuSdrtPMG6VJjLPUm7nSdYlwpzuSdpt/ME61JhLvck7XaeYF0qzOWepN3OE6xLhbnck7TbeYJ1qTCXe5J2O0+wLhXmck/SbucJ1qXCXO5J2u08wbpUmMs9SbudJ1iXCnO5J2m38wTrUmEu9yTtdp5gXSrM5Z6k3c4TrEuFudyTtNt5gnWpMJd7knY7T7AuFeZyT9Ju5wnWpcJc7kna7TzBulSYyz1Ju50nWJcKc7knabfzBOtSYS73JO12nmBdKszlnqTdzhOsS4W53JO023mCdakwl3uSdjtPsC4V5nJP0m7nCdalwlzuSdrtPMG6VJjLPUm7nSdYlwpzuSdpt/MEP58f+LXck7Sbv8Z9uSdpN3+N+3JP0m7+GvflnqTd/DXuyz1Ju/lr3Jd7knbz17gv9yTt5q9xX+5J2s1f477ck7Sbv8Z9uSdpN3+N+3JP0m7+GvflnqTd/DXuyz1Ju/lr3Jd7knbz17gv9yTt5q9xX+5J2s1f477ck7Sbv8Z9uSdpN3+N+3JP0m7+GvflnqTd/DXuyz1Ju/lr3Jd7knbz17gv9yTt5q9xX+5J2s1f477ck7Sbv8Z9uSdpN3+N+3JP0m7+GvflnqTd/DXuyz1Ju/lr3Jd7knY7/zVJ+rv5a5K+LX9N0rflr0n6tvw1Sd/Wf7TF9AHCcC8FAAAAAElFTkSuQmCC>

[image3]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZsAAABrCAIAAAAuH7gCAAAEt0lEQVR4Xu3UwYklSAwE0e/u+Ld+jQm995Sgiin4oNYL4pTnID9/AeC38MkBAMbi0QD8HvLRfn4+5M+f//7NyOnI5/NDZhYPeDR2lqu6NHI6UuPmQjOLBzwaO8tVXRo5Halxc6GZxQMejZ3lqi6NnI7UuLnQzOIBj8bOclWXRk5HatxcaGbxgEdjZ7mqSyOnIzVuLjSzeMCjsbNc1aWR05EaNxeaWTzg0dhZrurSyOlIjZsLzSwe8GjsLFd1aeR0pMbNhWYWD3g0dparujRyOlLj5kIziwc8GjvLVV0aOR2pcXOhmcUDHo2d5aoujZyO1Li50MziAY/GznJVl0ZOR2rcXGhm8YBHY2e5qksjpyM1bi40s3jAo7GzXNWlkdORGjcXmlk84NHYWa7q0sjpSI2bC80sHvBo7CxXdWnkdKTGzYVmFg94NHaWq7o0cjpS4+ZCM4sHPBo7y1VdGjkdqXFzoZnFAx6NneWqLo2cjtS4udDM4gGPxs5yVZdGTkdq3FxoZvGAR2NnuapLI6cjNW4uNLN4wKOxs1zVpZHTkRo3F5pZPODR2Fmu6tLI6UiNmwvNLB7waOwsV3Vp5HSkxs2FZhYPeDR2lqu6NHI6UuPmQjOLBzwaO8tVXRo5Halxc6GZxQMejZ3lqi6NnI7UuLnQzOIBj8bOclWXRk5HatxcaGbxgEdjZ7mqSyOnIzVuLjSzeMCjsbNc1aWR05EaNxeaWTzg0dhZrurSyOlIjZsLzSwe8GjsLFd1aeR0pMbNhWYWD3g0dparujRyOlLj5kIziwc8GjvLVV0aOR2pcXOhmcUDHo2d5aoujZyO1Li50MziAY/GznJVl0ZOR2rcXGhm8YBHY2e5qksjpyM1bi40s3jAo7GzXNWlkdORGjcXmlk84NHYWa7q0sjpSI2bC80sHvBo7CxXdWnkBHwZj8bOclWXRk7Al/Fo7CxXdWnkBHwZj8bOclWXRk7Al/Fo7CxXdWnkBHwZj8bOclWXRk7Al/Fo7CxXdWnkBHwZj8bOclWXRk7Al/Fo7CxXdWnkBHwZj8bOclWXRk7Al/FobIwqgClkuzVuLjSqAKaQ7da4udCoAphCtlvj5kKjCmAK2W6NmwuNKoApZLs1bi40qgCmkO3WuLnQqAKYQrZb4+ZCowpgCtlujZsLjSqAKWS7NW4uNKoAppDt1ri50KgCmEK2W+PmQqMKYArZbo2bC40qgClkuzVuLjSqAKaQ7da4udCoAphCtlvj5kKjCmAK2W6NmwuNKoApZLs1bi40qgCmkO3WuLnQqAKYQrZb4+ZCowpgCtnu5/NDRhXAFDwaG6MKYAoejY1RBTAFj8bGqAKYgkdjY1QBTMGjsTGqAKbg0dgYVQBT8GhsjCqAKXg0NkYVwBQ8GhujCmAKHo2NUQUwBY/GxqgCmIJHY2NUAUzBo7ExqgCm4NHYGFUAU/BobIwqgCl4NDZGFcAUPBobowpgCh6NjVEFMAWPxsaoApiCR2NjVAFMwaOxMaoApuDR2BhVAFPwaGyMKoApeDQ2RhXAFDwaG6MKYAoejY1RBTAFj8bGqAKYgkdjY1QBTMGjsTGqAKaQjwYAc/FoAH4PHg3A78GjAfg9/A/E8wcXWND7jwAAAABJRU5ErkJggg==>

[image4]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAaEAAAByCAIAAAB1F/mgAAAEi0lEQVR4Xu3UQYpcQQxEwbn/ZX2E8VakMKqNqPInHrHqRcGnE/38kaTv9pM/SNKHcuMkfTk3TtKXc+MkfTk3TtKXc+MkfTk3TtKX++eN+/39edDPzy//hdzTVP+vX9C/izflnkpuHCtyT1P9v35B/y7elHsquXGsyD1N9f/6Bf27eFPuqeTGsSL3NNX/6xf07+JNuaeSG8eK3NNU/69f0L+LN+WeSm4cK3JPU/2/fkH/Lt6Ueyq5cazIPU31//oF/bt4U+6p5MaxIvc01f/rF/Tv4k25p5Ibx4rc01T/r1/Qv4s35Z5Kbhwrck9T/b9+Qf8u3pR7KrlxrMg9TfX/+gX9u3hT7qnkxrEi9zTV/+sX9O/iTbmnkhvHitzTVP+vX9C/izflnkpuHCtyT1P9v35B/y7elHsquXGsyD1N9f/6Bf27eFPuqeTGsSL3NNX/6xf07+JNuaeSG8eK3NNU/69f0L+LN+WeSm4cK3JPU/2/fkH/Lt6Ueyq5cazIPU31//oF/bt4U+6p5MaxIvc01f/rF/Tv4k25p5Ibx4rc01R/Ac7lnkpuHCtyT1P9BTiXeyq5cazIPU31F+Bc7qnkxrEi9zTVX4BzuaeSG8eK3NNUfwHO5Z5Kbhwrck9T/QU4l3squXGsyD1N9RfgXO6p5MaxIvc01V+Ac7mnkhvHitzTVH8BzuWeSm4cK3JPU/0FOJd7KrlxrMg9TfUX4FzuqeTGsSL3NNVfgHO5p5Ibx4rc01R/Ac7lnkpuHCtyT1P9BTiXeyq5cazIPU31F+Bc7qnkxrEi9zTVX4BzuaeSG8eK3NNUfwHO5Z5Kbhwrck9T/QU4l3squXGsyD1N9RfgXO6p5MaxIvc01V+Ac7mnkhvHitzTVH8BzuWeSm4cK3JPU/0FOJd7KrlxrMg9TfUX4FzuqeTGsSL3NNVfgHO5p5Ibx4rc01R/Ac7lnkpuHCtyT1P9BTiXeyq5cazIPU31F+Bc7qnkxrEi9zTVX4BzuaeSG8eK3NNUfwHO5Z5Kbhwrck9T/QU4l3squXGsyD1Jl3LjWJF7ki7lxrEi9yRdyo1jRe5JupQbx4rck3QpN44VuSfpUm4cK3JP0qXcOFbknqRLuXGsyD1Jl3LjWJF7ki7lxrEi9yRdyo1jRe5JupQbx4rck3QpN44VuSfpUm4cK3JP0qXcOFbknqRLuXGsyD1Jl3LjWJF7ki7lxrEi9yRdyo1jRe5JupQbx4rck3QpN44VuSfpUm4cK3JP0qXcOFbknqRLuXGsyD1Jl3LjWJF7ki7lxrEi9yRdyo1jRe5JupQbx4rck3QpN44VuSfpUm4cK3JP0qXcOFbknqRLuXGsyD1Jl3LjWJF7ki7lxrEi9yRdyo1jRe5JupQbx4rck3QpN44VuSfpUm4cK3JP0qXcOFbknqRLuXGsyD1Jl3LjWJF7ki7lxrEi9yRdyo1jRe5JupQbx4rck3QpN44VuSfpUm4cK3JP0qXcOFbknqRLuXGsyD1Jl3LjWJF7ki71zxsnSR/IjZP05dw4SV/OjZP05dw4SV/OjZP05f4CzxV9B0sOOMMAAAAASUVORK5CYII=>

[image5]: <data:image/png;base64,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>

[image6]: <data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZwAAABwCAIAAACl0lEjAAAGGUlEQVR4Xu3Usa1k2REE0e8u/aMB1GkMTRiOnDFI9C7qCtsZhSM1UCU07ouf/zmO43zR/OQPjuM4/+Qxao7jfNUYNcdxvmqMmuM4XzV/iNqvXz/S3/ef//4l2B/161///kt4YVP2y6jpHrLVYX8Us9Xxwqbsl1HTPWSrw/4oZqvjhU3ZL6Ome8hWh/1RzFbHC5uyX0ZN95CtDvujmK2OFzZlv4ya7iFbHfZHMVsdL2zKfhk13UO2OuyPYrY6XtiU/TJquodsddgfxWx1vLAp+2XUdA/Z6rA/itnqeGFT9suo6R6y1WF/FLPV8cKm7JdR0z1kq8P+KGar44VN2S+jpnvIVof9UcxWxwubsl9GTfeQrQ77o5itjhc2Zb+Mmu4hWx32RzFbHS9syn4ZNd1Dtjrsj2K2Ol7YlP0yarqHbHXYH8VsdbywKftl1HQP2eqwP4rZ6nhhU/bLqOkestVhfxSz1fHCpuyXUdM9ZKvD/ihmq+OFTdkvo6Z7yFaH/VHMVscLm7JfRk33kK0O+6OYrY4XNmW/jJruIVsd9kcxWx0vbMp+GTXdQ7Y67I9itjpe2JT9Mmq6h2x12B/FbHW8sCn7ZdR0D9nqsD+K2ep4YVP2y6jpHrLVYX8Us9Xxwqbsl1HTPWSrw/4oZqvjhU3ZL6Ome8hWh/1RzFbHC5uyX0ZN95CtDvujmK2OFzZlv4ya7iFbHfZHMVsdL2zKfhk13UO2OuyPYrY6XtiU/TJquodsddgfxWx1vLAp+2XUdA/Z6rA/itnqeGFT9suo6R6y1WF/FLPV8cKm7JdR0z1kq8P+KGar44VN2S+jpnvIVof9UcxWxwubsl9GTfeQrQ77o5itjhc2Zb+Mmu4hWx32RzFbHS9syn4ZNd1Dtjrsj2K2Ol7YlP0yarqHbHXYH8VsdbywKftl1HQP2eqwP4rZ0ieyX0ZN95CtDvuj+LnqE9kvo6Z7yFaH/VH8XPWJ7JdR0z1kq8P+KH6u+kT2y6jpHrLVYX8UP1d9Ivtl1HQP2eqwP4qfqz6R/TJquodsddgfxc9Vn8h+GTXdQ7Y67I/i56pPZL+Mmu4hWx32R/Fz1SeyX0ZN95CtDvuj+LnqE9kvo6Z7yFaH/VH8XPWJ7JdR0z1kq8P+KH6u+kT2y6jpHrLVYX8UP1d9Ivtl1HQP2eqwP4qfqz6R/TJquodsddgfxc9Vn8h+GTXdQ7Y67I/i56pPZL+Mmu4hWx32R/Fz1SeyX0ZN95CtDvuj+LnqE9kvo6Z7yFaH/VH8XPWJ7JdR0z1kq8P+KH6u+kT2649R+/n5pd/493W8sInZkt7Jfhm1gtnqeGETn530TvbLqBXMVscLm/jspHeyX0atYLY6XtjEZye9k/0yagWz1fHCJj476Z3sl1ErmK2OFzbx2UnvZL+MWsFsdbywic9Oeif7ZdQKZqvjhU18dtI72S+jVjBbHS9s4rOT3sl+GbWC2ep4YROfnfRO9suoFcxWxwub+Oykd7JfRq1gtjpe2MRnJ72T/TJqBbPV8cImPjvpneyXUSuYrY4XNvHZSe9kv4xawWx1vLCJz056J/tl1Apmq+OFTXx20jvZL6NWMFsdL2zis5PeyX4ZtYLZ6nhhE5+d9E72y6gVzFbHC5v47KR3sl9GrWC2Ol7YxGcnvZP9MmoFs9XxwiY+O+md7JdRK5itjhc28dlJ72S/jFrBbHW8sInPTnon+2XUCmar44VNfHbSO9kvo1YwWx0vbOKzk97Jfhm1gtnqeGETn530TvbLqBXMVscLm/jspHeyX0atYLY6XtjEZye9k/0yagWz1fHCJj476Z3sl1ErmK2OFzbx2UnvZL+MWsFsdb839BufnfRO9suoFcxWx897E5+d9E72y6gVzFbHz3sTn530TvbLqBXMVsfPexOfnfRO9suoFcxWx897E5+d9E72y6gVzFbHz3sTn530TvbLqBXMVsfPexOfnfRO9suoFcxWx897E5+d9E72y6gVzFbHz3sTn530TvbLqBXMVsfPexOfnfRO9uuPUXMcx/nnjlFzHOerxqg5jvNVY9Qcx/mqMWqO43zVGDXHcb5qjJrjOF81/wejL/pKKW0sCwAAAABJRU5ErkJggg==>

[image7]: <data:image/png;base64,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>

[image8]: <data:image/png;base64,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>